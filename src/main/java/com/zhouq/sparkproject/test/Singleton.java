package com.zhouq.sparkproject.test;

/**
 * 单例模式 Demo
 *
 * 单例模式？
 *  我们自定义的类，其实在默认情况下都是可以让外界创建多个实例的。
 *  但是在某些时候，我们不希望外界来随意创建实例，而是希望一个类，在整个程序运行期间，只有一个实例。
 *
 *  那么，要实现单利模式，需要有下面几个要点：
 *  1.如果不想外界来创建实例，那么类就的构造方法就必须用private 修饰，必须是私有的。
 *  2.既然类的构造方法已经私有化类，外界不能使用构造器去创建类的实例，那么想要获取类的实例，就只有通过类的静态方法去获取了。
 *  3.所以类必须提供一个静态的方法 getInstance() 来提供唯一获取实例的共呢个。getInstance() 方法，必须保证类的实例创建，且仅创建一次，返回一个唯一的实例。
 *
 *  单利模式的应用场景：
 *  1.配置组件中，可以在读取大量的配置信息后，使用单利模式的方式，就将配置信息仅仅保存一个实例的的实例变量中。就可以避免对静态不变的配置，进行多次读取。
 *  2.JDBC 辅助组件，全局就只有一个实例，那么数据源也只有一个，不会重复创建多个数据源（数据库连接池）
 *
 *
 * @Author: zhouq
 * @Date: 2019-06-16
 * @Version: 1.0.0
 * @Since: JDK 1.8
 */
public class Singleton {

    /**
     * 第一步，必须又一个私有的静态变量。来引用即将被创建出来的单利。
     */
    private static Singleton instance = null;

    /**
     * 其次，必须对自己的构造方法使用private 进行私有化，这样才能保证外界的代码不能随意创建类的实例。
     */
    private Singleton(){

    }

    /**
     * 最后，需要有一个共有的静态方法，这个方法，负责创建类的唯一实例，并且返回这个唯一的实例。
     *
     * 必须考虑到可能出现的多线程并发访问的安全问题。
     * 就是说，可能有多个现场同时过来获取单利，那么就可能导致创建多次单利。所以，这个方法，通常是需要进行多线程并发访问的安全的限制。
     *
     * 很多朋友可能觉得不就是多线程并发访问的控制嘛，那就在方法上加 synchronized 关键词
     *
     * public static synchronized Singleton getInstance()
     *
     * 上面这么加会存在很大的问题，的确可以做到并发控制，但是在第一次创建完成实例以后，就会出现以后多个线程并发访问这个方法的时候，就会在方法级别进行同步，
     * 导致发送性能大幅度降低。
     *
     *
     * @return
     */
    public static Singleton getInstance(){
        //两步检查机制
        //首先判断instance 是否为null
        if (instance == null){
            //在这里进行线程的同步
            //同一时间，只能有一个线程获取到 Singleton Class 对象的 锁
            //进入后续的代码，其他线程都是只能在原地等待，获取锁
            synchronized (Singleton.class){
                //只有第一个获取到锁的线程，进入到这里，会发现是instance是null ，才会去创建这个单利。
                //之后的线程走到类这一步，也会发现instance 已经不是null 了。就不会再去创建这个单利了
                if (instance == null){
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
